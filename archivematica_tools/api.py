# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api.ipynb.

# %% auto 0
__all__ = ['ArchivematicaAPIClient']

# %% ../nbs/api.ipynb 3
import base64
import requests
import time
from requests.auth import HTTPBasicAuth
from typing import Optional, Dict
from tqdm import tqdm
from dotenv import load_dotenv
import os

# %% ../nbs/api.ipynb 4
class ArchivematicaAPIClient(object):
    """
    A client for interacting with Matica's API for file uploading, transferring, and ingesting processes.
    """

    TIME_SPAN = 2  # Time to wait in loops, in seconds

    def __init__(self, dashboard_url: str, dashboard_username: str, dashboard_api_key: str, storage_service_url: str, storage_service_username: str, storage_service_password: str):
        """
        Initializes the ArchivematicaAPIClient with necessary details for API interactions.

        Args:
            dashboard_url (str): URL of the dashboard.
            dashboard_username (str): Username for the dashboard.
            dashboard_api_key (str): API key for the dashboard.
            storage_service_url (str): URL of the storage service.
            storage_service_username (str): Username for the storage service.
            storage_service_password (str): Password for the storage service.
        """

        self.dashbord_url = dashboard_url
        self.dashboard_username = dashboard_username
        self.dashboard_api_key = dashboard_api_key

        self.dash_board_headers = {
            'Authorization': f'ApiKey {dashboard_username}:{dashboard_api_key}',
            "Content-Type": "application/json"
        }

        self.dash_board_endpoint = f"{dashboard_url}/api"

        self.storage_service_url = storage_service_url
        self.storage_username = storage_service_username
        self.storage_password = storage_service_password
    
    def v2beta_package(self, transfer_type: str, transfer_accession: str, location_uuid: str, path: str, name: str, processing_config: str) -> str:
        """
        Initiates a file transfer process.

        Args:
            transfer_type: The type of the transfer.
            transfer_accession: The accession number for the transfer.

        Returns:
            The directory associated with the transfer.
        """

        path = f"{location_uuid}:{path}"

        path_encoded = base64.b64encode(path.encode()).decode()
        data = {
            "name": name,
            "type": transfer_type,
            "accession": transfer_accession,
            "processing_config": processing_config,
            "path": path_encoded,
        }

        response = requests.post(f'{self.dashbord_url}/api/v2beta/package/', headers=self.dash_board_headers, json=data)

        self.transfer_UUID = response.json()["id"]
        return self.transfer_UUID
    
    def approve_transfer(self, transfer_type: str, directory: str) -> str:
        """
        Approves a file transfer after initiation.

        Args:
            transfer_type (str): The type of the transfer.
            directory (str): The directory associated with the transfer.

        Returns:
            Optional[str]: The UUID of the approved transfer, if available.
        """
        while True:
            data = {"type": transfer_type, "directory": directory}
            response = requests.post(f'{self.dashbord_url}/api/transfer/approve/', headers=self.dash_board_headers, data=data)
            if "uuid" in response.json():
                self.transfer_UUID = response.json()["uuid"]
                break
            time.sleep(self.TIME_SPAN)
        return self.transfer_UUID

    def check_transfer_status(self, transfer_UUID: str) -> str:
        """
        Checks the status of a file transfer until it is no longer processing.

        Args:
            transfer_UUID: The UUID of the transfer to check.

        Returns:
            The SIP UUID of the transfer.
        """
        while True:
            response = requests.get(f'{self.dashbord_url}/api/transfer/status/{transfer_UUID}', headers=self.dash_board_headers)
            r = response.json()
            if "status" in r and r["status"] != "PROCESSING":
                self.sip_uuid = r["sip_uuid"]
                break
            time.sleep(self.TIME_SPAN)
        return self.sip_uuid
    
    def transfer_delete(self, transfer_UUIDs: list) -> list:
        """
        Deletes the specified transfers.
        
        Args:
            transfer_UUIDs: The list of transfer UUIDs to delete.

        Returns:
            The results of the deletion.
        """
        results = []
        for transfer_UUID in transfer_UUIDs:
            response = requests.delete(f'{self.dashbord_url}/api/transfer/{transfer_UUID}/delete', headers=self.dash_board_headers)
            results.append(response.json())

        return results
    
    def transfer_completed(self) -> Dict:
        """
        Checks for completed transfers.

        Returns:
            The list of completed transfers.
        """

        response = requests.get(f'{self.dashbord_url}/api/transfer/completed', headers=self.dash_board_headers)

        return response.json()

    ###########

    def ingest(self, sip_UUID: str) -> str:
        """
        Waits for the ingestion process to complete and returns the UUID of the ingested AIP.

        Args:
            sip_UUID: The SIP UUID to ingest.

        Returns:
            The UUID of the ingested AIP.
        """
        while True:
            response = requests.get(f'{self.dash_board_endpoint}/ingest/status/{sip_UUID}', headers=self.dash_board_headers)
            r = response.json()
            if "status" in r and r["status"] != "PROCESSING":
                return r["uuid"]
            time.sleep(self.TIME_SPAN)

    def ingest_delete(self, ingest_UUIDs: list) -> list:
        """
        Deletes the specified ingestions.

        Args:
            ingest_UUIDs: The list of ingest UUIDs to delete.

        Returns:
            The results of the deletion.
        """
        results = []
        for ingest_UUID in ingest_UUIDs:
            response = requests.delete(f'{self.dash_board_endpoint}/ingest/{ingest_UUID}/delete', headers=self.dash_board_headers)
            results.append(response.json())

        return results

    def ingest_completed(self) -> Dict:
        """
        Checks for completed ingestions.

        Returns:
            The list of completed ingestions.
        """

        response = requests.get(f'{self.dash_board_endpoint}/ingest/completed', headers=self.dash_board_headers)

        return response.json()
    
    #####

    def v2_file(self, size:int = 20) -> list:
        """
        Retrieves a list of files.

        Args:
            size: The number of files to retrieve.

        Returns:
            The list of files.
        """
        response = requests.get(f'{self.storage_service_url}/api/v2/file/', auth=HTTPBasicAuth(self.storage_username, self.storage_password), params={"limit": size})
        return response.json()

    def v2_file_delete_aip(self, file_UUIDs: list, event_reason: str, pipeline: str, user_id: str, user_email: str) -> list:
        """
        Deletes the specified files.

        Args:
            file_UUIDs: The list of file UUIDs to delete.
            event_reason: The reason for the deletion.
            pipeline: The pipeline for the deletion.
            user_id: The user ID for the deletion.
            user_email: The user email for the deletion.

        Returns:
            The results of the deletion.
        """
        results = []
        for file_UUID in tqdm(file_UUIDs):
            response = requests.post(f'{self.storage_service_url}/api/v2/file/{file_UUID}/delete_aip/', auth=HTTPBasicAuth(self.storage_username, self.storage_password), json={
                "event_reason": event_reason,
                "pipeline": pipeline,
                "user_id"   : user_id,
                "user_email": user_email,

            })
            results.append(response.json())

        return results

    def v2_file_delete(self, file_UUIDs: list) -> list:
        """
        Deletes the specified files.

        Args:
            file_UUIDs: The list of file UUIDs to delete.

        Returns:
            The results of the deletion.
        """
        results = []
        for file_UUID in tqdm(file_UUIDs):
            response = requests.delete(f'{self.storage_service_url}/api/v2/file/{file_UUID}/contents', auth=HTTPBasicAuth(self.storage_username, self.storage_password))
            res = {
                "file_UUID": file_UUID,
            }
            if(response.status_code == 204):
                # results.append({"status": "success"})
                res["status"] = "success"
            else:
                # results.append({"status": "failed"})
                res["status"] = "failed"

            results.append(res)

        return results


    def get_aip_url(self, ingest_UUID: str) -> str:
        """
        Constructs and returns the URL for downloading the ingested AIP.

        Args:
            ingest_UUID: The UUID of the ingested AIP.

        Returns:
            The URL for downloading the AIP.
        """
        endpoint = self.storage_service_url + "/api"
        url = f"{endpoint}/v2/file/{ingest_UUID}/download/"
        return url
    
    def get_current_full_path(self, ingest_UUID: str) -> Optional[str]:
        """
        Retrieves the current full path of the ingested AIP by making an API call.

        Args:
            ingest_UUID (str): The UUID of the ingested AIP.

        Returns:
            Optional[str]: The current full path of the AIP if the request is successful, None otherwise.
        """
        endpoint = self.storage_service_url + "/api"
        url = f"{endpoint}/v2/file/{ingest_UUID}/"

        try:
            response = requests.get(url, auth=HTTPBasicAuth(self.storage_username, self.storage_password))
            response.raise_for_status()  # Raises an exception for 4XX or 5XX errors
            return response.json().get("current_full_path")
        except requests.RequestException as e:
            print(f"Error retrieving current full path: {e}")
            return None
        
    def check_status(self, transfer_UUID):
        """
        Checks the status of a file transfer until it is no longer processing.

        Args:
            transfer_UUID: The UUID of the transfer to check.

        Returns:
            The UUID of the ingested AIP.
        """
        print("transfer ...")
        sip_uuid = self.check_transfer_status(transfer_UUID)

        print("ingest ...")
        self.ingest(sip_uuid)

        return sip_uuid
        
    @staticmethod
    def main(transfer_type, transfer_accession, location_uuid, path, name, processing_config):
        """
        Main function to orchestrate the file transfer, ingestion, and deletion processes.

        Args:
            transfer_type: The type of the transfer.
            transfer_accession: The accession number for the transfer.

        Returns:
            The UUID of the ingested AIP.
        """
        load_dotenv(override=True)

        dashboard_url = os.environ.get("DASHBOARD_URL")
        dashboard_username = os.environ.get("DASHBOARD_USERNAME")
        dashboard_api_key = os.environ.get("DASHBOARD_API_KEY")

        storage_service_url = os.environ.get("STORAGE_SERVICE_URL")
        storage_service_username = os.environ.get("STORAGE_SERVICE_USERNAME")
        storage_service_password = os.environ.get("STORAGE_SERVICE_PASSWORD")

        client = ArchivematicaAPIClient(dashboard_url, dashboard_username, dashboard_api_key, storage_service_url, storage_service_username, storage_service_password)

        transfer_UUID = client.v2beta_package(transfer_type, transfer_accession, location_uuid, path, name, processing_config)
        sip_uuid = client.check_status(transfer_UUID)

        return sip_uuid

